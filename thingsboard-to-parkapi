#! /usr/bin/env python3

import requests
import os
import operator
import datetime
import json
from argparse import ArgumentParser

# this is a terrible hack and is necessary because of a misconfigured AAAA record
# see https://github.com/mfdz/digitransit-ansible/issues/11
# remove as soon as this ticket has been closed
import socket
import requests.packages.urllib3.util.connection as urllib3_cn

def allowed_gai_family():
    """
    https://github.com/shazow/urllib3/blob/master/urllib3/util/connection.py
    """
    family = socket.AF_INET # force IPv4
    return family

urllib3_cn.allowed_gai_family = allowed_gai_family

parser = ArgumentParser()
parser.add_argument("-o", "--output", help="write output to FILE", default="parkapi.json")
parser.add_argument("-g", "--geojson", help="the static geojson input file", default="parking_lots.geojson")
args = parser.parse_args()

base_url = "https://portal.mhascaro.com/api"

token_url = f"{base_url}/auth/login"

payload = {
    "username": os.environ['THINGSBOARD_USERNAME'],
    "password": os.environ['THINGSBOARD_PASSWORD']
}

response = requests.post(token_url, json=payload)
token = response.json()["token"]

auth_headers = {
    "X-Authorization": f"Bearer {token}"
}

list_url = f"{base_url}/entityGroup/3c521c80-53bd-11ea-aa10-3316385c1cc2/entities?limit=100"

response = requests.get(list_url, headers=auth_headers)

parking_lots = response.json().get("data", [])

def get_attribute(items, name):
    for i in items:
        if(i["key"] == name):
            return i["value"]

def get_timeseries_value(timeseries, name):
    val = timeseries[name][0]["value"]
    if val == None:
        return 0
    else:
        return int(float(val))

def fetch_dynamic_lot(lot):
    id = lot["id"]["id"]

    attribute_url = f"{base_url}/plugins/telemetry/ASSET/{id}/values/attributes?keys=address,latitude,longitude"
    attrs = requests.get(attribute_url, headers=auth_headers).json()

    timeseries_url = f"{base_url}/plugins/telemetry/ASSET/{id}/values/timeseries?keys=latestSumParkingState,SumOccupied,TotalParking_mapping"
    timeseries = requests.get(timeseries_url, headers=auth_headers).json()
    total = get_timeseries_value(timeseries, "TotalParking_mapping")
    occupied = get_timeseries_value(timeseries, "latestSumParkingState")
    free = total - occupied

    return {
        "id":               id,
        "lot_type":         "Parkplatz",
        "address":          get_attribute(attrs, "address"),
        "name":             get_attribute(attrs, "address"),
        "forecast":         False,
        "state":            "open",
        "coords" : {
            "lat":          get_attribute(attrs, "latitude"),
            "lng":          get_attribute(attrs, "longitude"),
        },
        "total":            total,
        "free":             free,
    }

def clean_nones(value):
    """
    Recursively remove all None values from dictionaries and lists, and returns
    the result as a new dictionary or list.
    """
    if isinstance(value, list):
        return [clean_nones(x) for x in value if x is not None]
    elif isinstance(value, dict):
        return {
            key: clean_nones(val)
            for key, val in value.items()
            if val is not None
        }
    else:
        return value

def fetch_static_lots():
    res = []
    with open(args.geojson, 'r', encoding='utf-8') as f:
        geojson = json.load(f)

        for lot in geojson["features"]:
            props = lot["properties"]
            coords = lot["geometry"]["coordinates"]
            l = {
                "id":               props.get("id"),
                "lot_type":         props["type"],
                "address":          props["name"],
                "name":             props["name"],
                "forecast":         False,
                "state":            "nodata",
                "coords" : {
                    "lat":          float(coords[1]),
                    "lng":          float(coords[0])
                },
                "total":            props["capacity"],
                "free":             props.get("free"),
                "url":              props.get("url"),
                "paid_hours":       props.get("paidHours"),
                "opening_hours":    props.get("openingHours")
            }
            res.append(clean_nones(l))

    return res

dynamic_lots = list(map(fetch_dynamic_lot, parking_lots))
static_lots = fetch_static_lots()

print(f"Fetched occupancy information for {len(dynamic_lots)} parking lots")
print(f"Fetched {len(static_lots)} static parking lots")

def merge_data(dynamic, static):
    for lot in static:
        id = lot.get("id")
        if(id != None):
            dynamic_lot = [x for x in dynamic if x["id"] == id][0]
            lot["free"] = dynamic_lot["free"]

    return static

utc_now = datetime.datetime.utcnow().isoformat()

parken_api_response = {
    "data_source": "https://www.herrenberg.de/de/Stadtleben/Erlebnis-Herrenberg/Service/Parkplaetze",
    "last_downloaded": utc_now,
    "last_updated": utc_now,
    "lots": merge_data(dynamic_lots, static_lots)
}

with open(args.output, 'w', encoding='utf-8') as f:
    json.dump(parken_api_response, f, ensure_ascii=False, indent=2)

print(f"Wrote output to {args.output}")
