#! /usr/bin/env python3

import requests
import os
import operator
import datetime
import json
from argparse import ArgumentParser

# this is a terrible hack and is necessary because of a misconfigured AAAA record
# see https://github.com/mfdz/digitransit-ansible/issues/11
# remove as soon as this ticket has been closed
import socket
import requests.packages.urllib3.util.connection as urllib3_cn

def allowed_gai_family():
    """
    https://github.com/shazow/urllib3/blob/master/urllib3/util/connection.py
    """
    family = socket.AF_INET # force IPv4
    return family

urllib3_cn.allowed_gai_family = allowed_gai_family

parser = ArgumentParser()
parser.add_argument("-o", "--output", help="write output to FILE", default="parkapi.json")
parser.add_argument("-g", "--geojson", help="the static geojson input file", default="parking_lots.geojson")
args = parser.parse_args()

base_url = "https://portal.mhascaro.com/api"

token_url = f"{base_url}/auth/login"

payload = {
    "username": os.environ['THINGSBOARD_USERNAME'],
    "password": os.environ['THINGSBOARD_PASSWORD']
}

response = requests.post(token_url, json=payload)
token = response.json()["token"]

auth_headers = {
    "X-Authorization": f"Bearer {token}"
}

def get_attribute(items, name):
    for i in items:
        if(i["key"] == name):
            return i["value"]

def get_timeseries_value(timeseries, name):
    val = timeseries[name][0]["value"]
    if val == None:
        return 0
    else:
        return int(float(val))

def fetch_dynamic_lot(id):

    print(f"Fetching information for lot {id}")

    attribute_url = f"{base_url}/plugins/telemetry/ASSET/{id}/values/attributes?keys=address,latitude,longitude"
    attrs = requests.get(attribute_url, headers=auth_headers).json()

    timeseries_url = f"{base_url}/plugins/telemetry/ASSET/{id}/values/timeseries?keys=latestSumParkingState,SumOccupied,TotalParking_mapping"
    timeseries = requests.get(timeseries_url, headers=auth_headers).json()
    total = get_timeseries_value(timeseries, "TotalParking_mapping")
    occupied = get_timeseries_value(timeseries, "latestSumParkingState")
    free = total - occupied

    return {
        "id":               id,
        "lot_type":         "Parkplatz",
        "address":          get_attribute(attrs, "address"),
        "name":             get_attribute(attrs, "address"),
        "forecast":         False,
        "state":            "open",
        "coords" : {
            "lat":          get_attribute(attrs, "latitude"),
            "lng":          get_attribute(attrs, "longitude"),
        },
        "total":            total,
        "free":             free,
    }

def clean_nones(value):
    """
    Recursively remove all None values from dictionaries and lists, and returns
    the result as a new dictionary or list.
    """
    if isinstance(value, list):
        return [clean_nones(x) for x in value if x is not None]
    elif isinstance(value, dict):
        return {
            key: clean_nones(val)
            for key, val in value.items()
            if val is not None
        }
    else:
        return value

def fetch_static_lots():
    res = []
    with open(args.geojson, 'r', encoding='utf-8') as f:
        geojson = json.load(f)

        for lot in geojson["features"]:
            props = lot["properties"]
            coords = lot["geometry"]["coordinates"]
            l = {
                "id":               props.get("id"),
                "lot_type":         props["type"],
                "address":          props["name"],
                "name":             props["name"],
                "forecast":         False,
                "state":            props.get("state", "nodata"),
                "lat":              float(coords[1]),
                "lon":              float(coords[0]),
                # deprecated: parkapi standard currently doesn't use nested properties...
                "coords" : {
                    "lat":          float(coords[1]),
                    "lng":          float(coords[0])
                },
                "total":            props.get("capacity"),
                "total:wheelchair": props.get("capacity:wheelchair"),

                "url":              props.get("url"),
                "fee_hours":        props.get("fee_hours"),
                "opening_hours":    props.get("opening_hours"),
                "notes":            props.get("notes")
            }

            res.append(clean_nones(l))

    return res

static_lots = fetch_static_lots()
ids = list(map(lambda lot : lot.get("id"), static_lots))
# remove Nones (strange python syntax if you ask me)
ids = list(filter(None, ids))

dynamic_lots = list(map(fetch_dynamic_lot, ids))

print(f"Fetched occupancy information for {len(dynamic_lots)} parking lots")
print(f"Fetched {len(static_lots)} static parking lots")

def merge_data(dynamic, static):
    for lot in static:
        id = lot.get("id")
        if id != None and lot["state"] != "closed":
            dynamic_lots = [x for x in dynamic if x["id"] == id]
            if len(dynamic_lots) > 0:
                dynamic_lot = dynamic_lots[0]

                free = dynamic_lot["free"]
                total = lot.get("total", "total:wheelchair")

                if lot["lot_type"] == "Barrierefreier-Parkplatz":
                    lot["free:wheelchair"] = free
                else:
                    lot["free"] = free

                if free <= 0:
                    lot["status"] = "full"
                elif free <= 5 or free/total < 0.05:
                    lot["status"] = "few"
                else:
                    lot["status"] = "many"
        else:
            lot["status"] = "nodata"



    return static

utc_now = datetime.datetime.utcnow().isoformat()

parken_api_response = {
    "data_source": "https://www.herrenberg.de/de/Stadtleben/Erlebnis-Herrenberg/Service/Parkplaetze",
    "last_downloaded": utc_now,
    "last_updated": utc_now,
    "lots": merge_data(dynamic_lots, static_lots)
}

with open(args.output, 'w', encoding='utf-8') as f:
    json.dump(parken_api_response, f, ensure_ascii=False, indent=2)

print(f"Wrote output to {args.output}")
